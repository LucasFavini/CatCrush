<!DOCTYPE html>
<html lang="es">
<head>
    <audio id="match-sound" src="assets/match_sound.mp3"></audio>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cat Match ‚Äì Prototipo</title>
    <style>
        :root {
            --tile: 64px; /* tama√±o visual de cada celda */
            --gap: 6px;
            --bg: #0e0f14;
            --panel: #161821;
            --accent: #7dd3fc;
            --accent-2: #a78bfa;
            --text: #e5e7eb;
            --danger: #ef4444;
            --success: #22c55e;
        }
        * { box-sizing: border-box; }
        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
            background: radial-gradient(1000px 600px at 20% 0%, #151825, #0b0c12 60%);
            color: var(--text);
            display: grid;
            place-items: center;
            min-height: 100vh;
        }
        .wrap {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 20px;
            width: min(100%, 980px);
            padding: 24px;
        }
        .panel {
            background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.35);
            padding: 16px;
        }
        .hud {
            display: grid;
            gap: 12px;
            align-content: start;
            min-width: 240px;
        }
        .hud h1 { font-size: 20px; margin: 0 0 6px; letter-spacing: 0.5px; }
        .stat { display: flex; justify-content: space-between; font-variant-numeric: tabular-nums; }
        .bar {
            height: 8px; background: #0e1118; border-radius: 999px; overflow: hidden; border:1px solid rgba(255,255,255,0.06);
        }
        .bar > span { display:block; height:100%; width:0%; background: linear-gradient(90deg, var(--accent), var(--accent-2)); transition: width 300ms ease; }

        #board {
            display: grid;
            grid-template-columns: repeat(var(--cols), var(--tile));
            grid-template-rows: repeat(var(--rows), var(--tile));
            gap: var(--gap);
            padding: var(--gap);
            background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 18px;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03), 0 20px 40px rgba(0,0,0,0.35);
            position: relative;
        }

        .tile {
            width: var(--tile);
            height: var(--tile);
            border-radius: 12px;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08);
            display: grid; place-items: center;
            cursor: pointer;
            transition: transform 120ms ease, box-shadow 120ms ease, filter 120ms ease;
            user-select: none;
            position: relative;
            overflow: hidden;
        }
        .tile img { width: 80%; image-rendering: pixelated; }
        .tile:hover { transform: translateY(-2px); box-shadow: 0 6px 14px rgba(0,0,0,0.35); }
        .tile.selected {
            outline: 3px solid var(--accent);
            z-index: 2;
            filter: saturate(1.3);
        }
        .tile.clearing { animation: pop 280ms ease forwards; }
        @keyframes pop { 0%{ transform: scale(1); opacity:1 } 70%{ transform: scale(1.15); } 100% { transform: scale(0.4); opacity:0 } }

        .btn {
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            color: #0b0c12; font-weight: 700; border: none; padding: 10px 14px; border-radius: 10px; cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.35);
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .row { display:flex; gap:10px; align-items:center; }
        small { color:#9aa4b2 }
        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            text-align: center;
            z-index: 10;
            display: none;
        }
        .game-message h2 { margin-top: 0; }
        .game-message.show { display: block; }
        
        /* Reglas CSS para pantallas m√°s peque√±as (celulares) */
        @media screen and (max-width: 768px) {
            body {
                display: block;
                padding: 16px;
            }
            .wrap {
                grid-template-columns: 1fr;
                gap: 16px;
                padding: 0;
            }
            .hud {
                min-width: unset;
            }
            #board {
                /* Asegura que el tablero no se desborde en pantallas peque√±as */
                width: 100%;
                /* Ajusta el tama√±o de los cuadros para que quepan en la pantalla */
                --tile: clamp(32px, 10vw, 50px);
            }
            .panel {
                /* Estilos para el panel en pantallas m√≥viles */
                padding: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="wrap">
        <div id="board" class="panel" aria-label="Tablero"></div>
        <aside class="panel hud">
            <h1>üêæ Cat Match ‚Äì Prototipo</h1>
            <div class="stat"><span>Nivel</span><strong id="level">1</strong></div>
            <div class="stat"><span>Objetivo</span><strong id="target-score">100</strong></div>
            <div class="stat"><span>Puntaje</span><strong id="score">0</strong></div>
            <div class="bar"><span id="scoreBar"></span></div>
            <div class="stat"><span>Movimientos</span><strong id="moves">20</strong></div>
            <div class="stat"><span>Tiempo</span><strong id="timer">60</strong></div>
            <div class="row">
                <button id="reset" class="btn">Reiniciar</button>
            </div>
            <small>Consejo: selecciona dos gatitos adyacentes para intercambiar. Si no hay match, se revierte.</small>
        </aside>
    </div>

    <div id="game-message" class="game-message">
        <h2 id="message-text"></h2>
        <button id="next-level-btn" class="btn" style="display:none;">Siguiente Nivel</button>
        <button id="try-again-btn" class="btn" style="display:none;">Intentar de Nuevo</button>
    </div>

    <script>
        // ... (el script JavaScript de la versi√≥n anterior)
        const ROWS = 8;
        const COLS = 8;
        const TYPES = ["cat_orange.png", "cat_black.png", "cat_white.png", "cat_gray.png"];
        const boardEl = document.getElementById('board');
        const scoreEl = document.getElementById('score');
        const scoreBar = document.getElementById('scoreBar');
        const movesEl = document.getElementById('moves');
        const timerEl = document.getElementById('timer');
        const levelEl = document.getElementById('level');
        const targetScoreEl = document.getElementById('target-score');
        const resetBtn = document.getElementById('reset');
        const gameMessageEl = document.getElementById('game-message');
        const messageTextEl = document.getElementById('message-text');
        const nextLevelBtn = document.getElementById('next-level-btn');
        const tryAgainBtn = document.getElementById('try-again-btn');
        boardEl.style.setProperty('--rows', ROWS);
        boardEl.style.setProperty('--cols', COLS);
        let board = [];
        let score = 0;
        let moves = 0;
        let level = 1;
        let targetScore = 100;
        let timeRemaining = 60;
        let timerInterval;
        let locked = false;
        let selected = null;
        const levelData = {
            1: { targetScore: 100, moves: 20, time: 60 },
            2: { targetScore: 250, moves: 25, time: 55 },
            3: { targetScore: 450, moves: 25, time: 50 },
            4: { targetScore: 700, moves: 30, time: 45 },
            5: { targetScore: 1000, moves: 30, time: 40 },
        };
        function rng(max){ return Math.floor(Math.random()*max); }
        function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }
        function createBoard(){
            board = Array.from({length: ROWS}, ()=> Array(COLS).fill(0));
            for(let r=0;r<ROWS;r++){
                for(let c=0;c<COLS;c++){
                    board[r][c] = randomTileAvoiding(r,c);
                }
            }
        }
        function randomTileAvoiding(r,c){
            const pool = [0,1,2,3];
            while(pool.length){
                const i = rng(pool.length);
                const val = pool.splice(i,1)[0];
                if (createsMatch(r,c,val)) continue;
                return val;
            }
            return 0;
        }
        function createsMatch(r,c,val){
            if (c>=2 && board[r][c-1]===val && board[r][c-2]===val) return true;
            if (r>=2 && board[r-1][c]===val && board[r-2][c]===val) return true;
            return false;
        }
        function render(){
            boardEl.innerHTML = '';
            for(let r=0;r<ROWS;r++){
                for(let c=0;c<COLS;c++){
                    const tile = document.createElement('button');
                    tile.className = 'tile';
                    tile.dataset.r = r; tile.dataset.c = c;
                    const val = board[r][c];
                    if (val !== null){
                        const img = document.createElement('img');
                        img.alt = `Gatito ${val}`;
                        img.src = `assets/${TYPES[val]}`;
                        tile.appendChild(img);
                    }
                    tile.addEventListener('click', onTileClick);
                    if (selected && selected.r===r && selected.c===c) tile.classList.add('selected');
                    boardEl.appendChild(tile);
                }
            }
            scoreEl.textContent = score;
            scoreBar.style.width = Math.min(100, (score / targetScore) * 100) + '%';
            movesEl.textContent = moves;
            timerEl.textContent = timeRemaining;
            levelEl.textContent = level;
            targetScoreEl.textContent = targetScore;
        }
        function onTileClick(e){
            if (locked || moves <= 0 || timeRemaining <= 0) return;
            const r = +e.currentTarget.dataset.r;
            const c = +e.currentTarget.dataset.c;
            if (!selected){ selected = {r,c}; render(); return; }
            const {r: r0, c: c0} = selected;
            if (r===r0 && c===c0){ selected=null; render(); return; }
            if (!areAdjacent(r0,c0,r,c)){ selected=null; render(); return; }
            doSwap({r:r0,c:c0}, {r,c}, true);
            moves--;
            movesEl.textContent = moves;
        }
        function areAdjacent(r1,c1,r2,c2){
            const dr = Math.abs(r1-r2), dc = Math.abs(c1-c2);
            return dr+dc===1;
        }
        function doSwap(a,b,playerInitiated=false){
            locked = true;
            swapValues(a,b);
            const matches = findMatches();
            if (matches.length===0){
                setTimeout(()=>{
                    swapValues(a,b);
                    selected = null; locked=false; render();
                }, 120);
                // if(playerInitiated) moves = levelData[level].moves; -1; //aca
                return;
            }
            selected = null;
            resolveMatchesLoop(matches);
        }
        function swapValues(a,b){
            const t = board[a.r][a.c];
            board[a.r][a.c] = board[b.r][b.c];
            board[b.r][b.c] = t;
            render();
        }
        function findMatches(){
            const toClear = [];
            for(let r=0;r<ROWS;r++){
                let runVal = board[r][0], runStart = 0;
                for(let c=1;c<=COLS;c++){
                    const v = c<COLS ? board[r][c] : null;
                    if (v!==runVal){
                        const runLen = c-runStart;
                        if (runVal!==null && runLen>=3){
                            for(let k=runStart;k<c;k++) toClear.push({r,c:k});
                        }
                        runVal = v; runStart = c;
                    }
                }
            }
            for(let c=0;c<COLS;c++){
                let runVal = board[0][c], runStart = 0;
                for(let r=1;r<=ROWS;r++){
                    const v = r<ROWS ? board[r][c] : null;
                    if (v!==runVal){
                        const runLen = r-runStart;
                        if (runVal!==null && runLen>=3){
                            for(let k=runStart;k<r;k++) toClear.push({r:k,c});
                        }
                        runVal = v; runStart = r;
                    }
                }
            }
            const key = p=> `${p.r},${p.c}`;
            const map = new Map();
            toClear.forEach(p=> map.set(key(p), p));
            return [...map.values()];
        }
        function resolveMatchesLoop(initial){
            if(initial.length > 0){
                document.getElementById("match-sound").currentTime = 0;
                document.getElementById("match-sound").play();
            }
            animateClear(initial).then(()=>{
                initial.forEach(({r,c})=>{ board[r][c] = null; });
                score += initial.length * 10;
                render();
                dropAndFill();
                render();
                initial.forEach(({r,c})=>{
                    const idx = r*COLS + c;
                    const node = boardEl.children[idx];
                    if(node){
                        const img = node.querySelector('img');
                        const originalSrc = img.src;
                        img.src = 'cat_gold.png'; // usar GIF
                        setTimeout(()=>{ img.src = originalSrc; }, 100); // volver al sprite normal
                    }
                });
                setTimeout(()=>{
                    const more = findMatches();
                    if(more.length>0){
                        resolveMatchesLoop(more);
                    } else {
                        locked = false;
                        checkGameConditions();
                    }
                }, 120);
            });
        }
        function animateClear(cells){
            const nodes = [];
            for (const {r,c} of cells){
                const idx = r*COLS + c;
                const node = boardEl.children[idx];
                if (node){ node.classList.add('clearing'); nodes.append?.(node); }
            }
            return new Promise(res=> setTimeout(res, 220));
        }
        function dropAndFill(){
            for(let c=0;c<COLS;c++){
                let write = ROWS-1;
                for(let r=ROWS-1;r>=0;r--){
                    if (board[r][c]!==null){
                        board[write][c] = board[r][c];
                        if (write!==r) board[r][c] = null;
                        write--;
                    }
                }
                for(let r=write;r>=0;r--){
                    board[r][c] = rng(4);
                }
            }
        }
        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timeRemaining--;
                timerEl.textContent = timeRemaining;
                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    checkLossConditions();
                }
            }, 1000);
        }
        function checkGameConditions() {
            if (score >= targetScore) {
                showWinMessage();
            } else if (moves <= 0 || timeRemaining <= 0) {
                checkLossConditions();
            }
        }
        function checkLossConditions() {
            if (score < targetScore) {
                showLossMessage();
            }
        }
        function showWinMessage() {
            clearInterval(timerInterval);
            locked = true;
            messageTextEl.textContent = `¬°Felicidades! Completaste el Nivel ${level} üéâ`;
            nextLevelBtn.style.display = 'inline-block';
            tryAgainBtn.style.display = 'none';
            gameMessageEl.classList.add('show');
        }
        function showLossMessage() {
            clearInterval(timerInterval);
            locked = true;
            messageTextEl.textContent = `¬°Perdiste! Intenta de nuevo üòø`;
            nextLevelBtn.style.display = 'none';
            tryAgainBtn.style.display = 'inline-block';
            gameMessageEl.classList.add('show');
        }
        function nextLevel() {
            gameMessageEl.classList.remove('show');
            level++;
            if (levelData[level]) {
                targetScore = levelData[level].targetScore;
                moves = levelData[level].moves;
                timeRemaining = levelData[level].time;
            } else {
                targetScore += 200;
                moves += 5;
                timeRemaining = Math.max(15, timeRemaining - 5);
            }
            resetGame();
        }
        function resetGame() {
            gameMessageEl.classList.remove('show');
            score = 0;
            selected = null;
            locked = false;
            createBoard();
            render();
            startTimer();
        }
        function reset() {
            level = 1;
            targetScore = levelData[1].targetScore;
            moves = levelData[1].moves;
            timeRemaining = levelData[1].time;
            resetGame();
        }
        nextLevelBtn.addEventListener('click', nextLevel);
        tryAgainBtn.addEventListener('click', reset);
        resetBtn.addEventListener('click', reset);
        reset();
    </script>
</body>
</html>
