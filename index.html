<!DOCTYPE html>
<html lang="es">
<head>
    <audio id="match-sound" src="assets/match_sound.mp3"></audio>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Cat Match ‚Äì Prototipo</title>
    <style>
        :root {
            --tile: 64px; /* tama√±o visual de cada celda */
            --gap: 6px;
            --bg: #0e0f14;
            --panel: #161821;
            --accent: #7dd3fc;
            --accent-2: #a78bfa;
            --text: #e5e7eb;
            --danger: #ef4444;
            --success: #22c55e;
        }
        * { box-sizing: border-box; }
        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
            background: radial-gradient(1000px 600px at 20% 0%, #151825, #0b0c12 60%);
            color: var(--text);
            display: grid;
            place-items: center;
            min-height: 100vh;
        }
        .wrap {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 20px;
            width: min(100%, 980px);
            padding: 24px;
        }
        .panel {
            background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.35);
            padding: 16px;
        }
        .hud {
            display: grid;
            gap: 12px;
            align-content: start;
            min-width: 240px;
        }
        .hud h1 { font-size: 20px; margin: 0 0 6px; letter-spacing: 0.5px; }
        .stat { display: flex; justify-content: space-between; font-variant-numeric: tabular-nums; }
        .bar {
            height: 8px; background: #0e1118; border-radius: 999px; overflow: hidden; border:1px solid rgba(255,255,255,0.06);
        }
        .bar > span { display:block; height:100%; width:0%; background: linear-gradient(90deg, var(--accent), var(--accent-2)); transition: width 300ms ease; }

        #board {
            display: grid;
            grid-template-columns: repeat(var(--cols), var(--tile));
            grid-template-rows: repeat(var(--rows), var(--tile));
            gap: var(--gap);
            padding: var(--gap);
            background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 18px;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03), 0 20px 40px rgba(0,0,0,0.35);
            position: relative;
        }

        .tile {
            width: var(--tile);
            height: var(--tile);
            border-radius: 12px;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08);
            display: grid; place-items: center;
            cursor: pointer;
            transition: transform 120ms ease, box-shadow 120ms ease, filter 120ms ease;
            user-select: none;
            position: relative;
            overflow: hidden;
        }
        .tile img { width: 80%; image-rendering: pixelated; pointer-events: none; }
        .tile:hover { transform: translateY(-2px); box-shadow: 0 6px 14px rgba(0,0,0,0.35); }
        .tile.selected {
            outline: 3px solid var(--accent);
            z-index: 2;
            filter: saturate(1.3);
        }
        .tile.clearing { animation: pop 280ms ease forwards; }
        @keyframes pop { 0%{ transform: scale(1); opacity:1 } 70%{ transform: scale(1.15); } 100% { transform: scale(0.4); opacity:0 } }
        .tile.dragging { opacity: 0.5; }

        .btn {
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            color: #0b0c12; font-weight: 700; border: none; padding: 10px 14px; border-radius: 10px; cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.35);
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .row { display:flex; gap:10px; align-items:center; }
        small { color:#9aa4b2 }
        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            text-align: center;
            z-index: 10;
            display: none;
        }
        .game-message h2 { margin-top: 0; }
        .game-message.show { display: block; }
        .no-scroll {
            overflow: hidden;
        }

        /* Reglas CSS para pantallas m√°s peque√±as (celulares) */
        @media screen and (max-width: 768px) {
            body {
                display: block;
                padding: 16px;
            }
            .wrap {
                grid-template-columns: 1fr;
                gap: 16px;
                padding: 0;
            }
            .hud {
                min-width: unset;
            }
            #board {
                width: 100%;
                --tile: clamp(32px, 10vw, 50px);
            }
            .panel {
                padding: 12px;
            }
        }
        @media screen and (min-width: 768px) and (max-width: 1024px) {
            body {
                padding: 0;
            }
            .wrap {
                width: 100%;
                max-width: 100%;
                grid-template-columns: 1fr;
                gap: 20px;
                padding: 20px;
            }
            .panel {
                width: 100%;
                box-sizing: border-box;
            }
            #board {
                --tile: 11vmin
            }
            .hud {
                justify-content: center;
                text-align: center;
            }
            .hud .row {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="wrap">
        <aside class="panel hud">
            <div class="row">
                <span>üìà</span><strong id="level">1</strong>
                <span>üèÜ</span><strong id="target-score">100</strong>
                <span>üéØ</span><strong id="score">0</strong>
                <span>üîÄ</span><strong id="moves">20</strong>
            </div>
            <div class="bar"><span id="scoreBar"></span></div>
            <!-- <div class="row">
                <button id="reset" class="btn">‚ü≥</button>
            </div> -->
            <small>Consejo: arrastra un gatito para intercambiarlo con uno adyacente.</small>
        </aside>
        <div id="board" class="panel" aria-label="Tablero"></div>
    </div>

    <div id="game-message" class="game-message">
        <h2 id="message-text"></h2>
        <button id="next-level-btn" class="btn" style="display:none;">‚â´</button>
        <button id="try-again-btn" class="btn" style="display:none;">‚ü≥</button>
    </div>

    <script>
        const ROWS = 8;
        const COLS = 8;
        const TYPES = ["cat_orange1.png", "cat_magenta.png", "cat_white1.png", "cat_cian.png"];
        const boardEl = document.getElementById('board');
        const scoreEl = document.getElementById('score');
        const scoreBar = document.getElementById('scoreBar');
        const movesEl = document.getElementById('moves');
        const levelEl = document.getElementById('level');
        const targetScoreEl = document.getElementById('target-score');
        const resetBtn = document.getElementById('reset');
        const gameMessageEl = document.getElementById('game-message');
        const messageTextEl = document.getElementById('message-text');
        const nextLevelBtn = document.getElementById('next-level-btn');
        const tryAgainBtn = document.getElementById('try-again-btn');
        const matchSound = document.getElementById('match-sound');

        boardEl.style.setProperty('--rows', ROWS);
        boardEl.style.setProperty('--cols', COLS);

        let board = [];
        let score = 0;
        let moves = 0;
        let level = 1;
        let targetScore = 100;
        let locked = false;
        let selectedTile = null;

        const levelData = {
            1: { targetScore: 100, moves: 20 },
            2: { targetScore: 250, moves: 25 },
            3: { targetScore: 450, moves: 25 },
            4: { targetScore: 700, moves: 30 },
            5: { targetScore: 1000, moves: 30 },
        };

        function rng(max) { return Math.floor(Math.random() * max); }
        function inBounds(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }

        function createBoard() {
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    board[r][c] = randomTileAvoiding(r, c);
                }
            }
        }

        function randomTileAvoiding(r, c) {
            const pool = [0, 1, 2, 3];
            while (pool.length) {
                const i = rng(pool.length);
                const val = pool.splice(i, 1)[0];
                if (createsMatch(r, c, val)) continue;
                return val;
            }
            return 0;
        }

        function createsMatch(r, c, val) {
            if (c >= 2 && board[r][c - 1] === val && board[r][c - 2] === val) return true;
            if (r >= 2 && board[r - 1][c] === val && board[r - 2][c] === val) return true;
            return false;
        }

        function render() {
            boardEl.innerHTML = '';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const tile = document.createElement('button');
                    tile.className = 'tile';
                    tile.dataset.r = r;
                    tile.dataset.c = c;

                    const val = board[r][c];
                    if (val !== null) {
                        const img = document.createElement('img');
                        img.alt = `Gatito ${val}`;
                        img.src = `assets/${TYPES[val]}`;
                        tile.appendChild(img);
                    }
                    tile.addEventListener('pointerdown', onPointerDown);
                    tile.addEventListener('pointerenter', onPointerEnter);

                    // Touch support for mobile drag
                    tile.addEventListener('touchstart', function(e) {
                        e.preventDefault();
                        onPointerDown({ currentTarget: tile, preventDefault: () => {} });
                    }, { passive: false });

                    tile.addEventListener('touchmove', function(e) {
                        if (!selectedTile) return;
                        const touch = e.touches[0];
                        const elem = document.elementFromPoint(touch.clientX, touch.clientY);
                        if (elem && elem.classList.contains('tile') && elem !== selectedTile) {
                            onPointerEnter({ currentTarget: elem });
                        }
                    }, { passive: false });

                    tile.addEventListener('touchend', function(e) {
                        onPointerUp();
                    }, { passive: false });
                    
                    boardEl.appendChild(tile);
                }
            }
            
            document.addEventListener('pointerup', onPointerUp);

            scoreEl.textContent = score;
            scoreBar.style.width = Math.min(100, (score / targetScore) * 100) + '%';
            movesEl.textContent = moves;
            levelEl.textContent = level;
            targetScoreEl.textContent = targetScore;
        }

        // Nuevo controlador para evitar el scroll del cuerpo
        function disableBodyScroll(e) {
            e.preventDefault();
        }

        function onPointerDown(e) {
            if (locked || moves <= 0) return;
            selectedTile = e.currentTarget;
            selectedTile.classList.add('selected');
            // Desactiva el scroll de la p√°gina solo cuando se toca el tablero
            document.body.classList.add('no-scroll');
            // Usa e.preventDefault() en el evento para detener cualquier acci√≥n por defecto
            e.preventDefault();
        }

        function onPointerEnter(e) {
            if (!selectedTile || e.currentTarget === selectedTile) return;

            const targetTile = e.currentTarget;
            const r1 = +selectedTile.dataset.r;
            const c1 = +selectedTile.dataset.c;
            const r2 = +targetTile.dataset.r;
            const c2 = +targetTile.dataset.c;

            if (areAdjacent(r1, c1, r2, c2)) {
                animateSwap(selectedTile, targetTile).then(() => {
                    doSwap({ r: r1, c: c1 }, { r: r2, c: c2 });
                    // moves--;
                    movesEl.textContent = moves;
                });
            }

            selectedTile.classList.remove('selected');
            selectedTile = null;
        }

        function onPointerUp() {
            if (selectedTile) {
                selectedTile.classList.remove('selected');
                selectedTile = null;
            }
            // Habilita el scroll de la p√°gina cuando el puntero se levanta
            document.body.classList.remove('no-scroll');
        }

        function animateSwap(tile1, tile2) {
            return new Promise(resolve => {
                const rect1 = tile1.getBoundingClientRect();
                const rect2 = tile2.getBoundingClientRect();
                
                const dx = rect2.left - rect1.left;
                const dy = rect2.top - rect1.top;
                
                tile1.style.transition = 'transform 200ms ease-in-out';
                tile2.style.transition = 'transform 200ms ease-in-out';
                
                tile1.style.transform = `translate(${dx}px, ${dy}px)`;
                tile2.style.transform = `translate(${-dx}px, ${-dy}px)`;

                setTimeout(() => {
                    tile1.style.transform = '';
                    tile2.style.transform = '';
                    tile1.style.transition = '';
                    tile2.style.transition = '';
                    resolve();
                }, 200);
            });
        }

        function areAdjacent(r1, c1, r2, c2) {
            const dr = Math.abs(r1 - r2), dc = Math.abs(c1 - c2);
            return dr + dc === 1;
        }

        function doSwap(a, b) {
            locked = true;
            const t = board[a.r][a.c];
            board[a.r][a.c] = board[b.r][b.c];
            board[b.r][b.c] = t;

            const matches = findMatches();
            if (matches.length === 0) {
                setTimeout(() => {
                    const t2 = board[a.r][a.c];
                    board[a.r][a.c] = board[b.r][b.c];
                    board[b.r][b.c] = t2;
                    render();
                    locked = false;
                }, 250); 
                return;
            }
            
            selectedTile = null;
            render();
            resolveMatchesLoop(matches);
        }

        function findMatches() {
            const toClear = [];
            for (let r = 0; r < ROWS; r++) {
                let runVal = board[r][0], runStart = 0;
                for (let c = 1; c <= COLS; c++) {
                    const v = c < COLS ? board[r][c] : null;
                    if (v !== runVal) {
                        const runLen = c - runStart;
                        if (runVal !== null && runLen >= 3) {
                            for (let k = runStart; k < c; k++) toClear.push({ r, c: k });
                        }
                        runVal = v;
                        runStart = c;
                    }
                }
            }
            for (let c = 0; c < COLS; c++) {
                let runVal = board[0][c], runStart = 0;
                for (let r = 1; r <= ROWS; r++) {
                    const v = r < ROWS ? board[r][c] : null;
                    if (v !== runVal) {
                        const runLen = r - runStart;
                        if (runVal !== null && runLen >= 3) {
                            for (let k = runStart; k < r; k++) toClear.push({ r: k, c });
                        }
                        runVal = v;
                        runStart = r;
                    }
                }
            }
            const key = p => `${p.r},${p.c}`;
            const map = new Map();
            toClear.forEach(p => map.set(key(p), p));
            return [...map.values()];
        }

        function resolveMatchesLoop(initial) {
            if (initial.length > 0) {
                matchSound.currentTime = 0;
                matchSound.play();
            }

            const nodesToClear = [];
            for (const { r, c } of initial) {
                const idx = r * COLS + c;
                const node = boardEl.children[idx];
                if (node) {
                    node.classList.add('clearing');
                    const img = node.querySelector('img');
                    if (img) {
                        img.src = 'cat_gold.png';
                    }
                    nodesToClear.push(node);
                }
            }
            score += initial.length * 10;
            
            setTimeout(() => {
                initial.forEach(({ r, c }) => {
                    board[r][c] = null;
                });

                dropAndFill();
                render();

                const more = findMatches();
                if (more.length > 0) {
                    resolveMatchesLoop(more);
                } else {
                    locked = false;
                    checkGameConditions();
                }
            }, 300);
        }

        function animateClear(cells) {
            const nodes = [];
            for (const { r, c } of cells) {
                const idx = r * COLS + c;
                const node = boardEl.children[idx];
                if (node) { node.classList.add('clearing'); nodes.push(node); }
            }
            return new Promise(res => setTimeout(res, 220));
        }

        function dropAndFill() {
            for (let c = 0; c < COLS; c++) {
                let write = ROWS - 1;
                for (let r = ROWS - 1; r >= 0; r--) {
                    if (board[r][c] !== null) {
                        board[write][c] = board[r][c];
                        if (write !== r) board[r][c] = null;
                        write--;
                    }
                }
                for (let r = write; r >= 0; r--) {
                    board[r][c] = rng(4);
                }
            }
        }

        function checkGameConditions() {
            if (score >= targetScore) {
                showWinMessage();
            } else if (moves <= 0) {
                checkLossConditions();
            }
        }

        function checkLossConditions() {
            if (score < targetScore) {
                showLossMessage();
            }
        }

        function showWinMessage() {
            locked = true;
            messageTextEl.textContent = `¬°Felicidades! Completaste el Nivel ${level} üéâ`;
            nextLevelBtn.style.display = 'inline-block';
            tryAgainBtn.style.display = 'none';
            gameMessageEl.classList.add('show');
        }

        function nextLevel() {
            gameMessageEl.classList.remove('show');
            level++;
            if (levelData[level]) {
                targetScore = levelData[level].targetScore;
                moves = levelData[level].moves;
            } else {
                targetScore += 200;
                moves += 5;
            }
            resetGame();
        }

        function resetGame() {
            gameMessageEl.classList.remove('show');
            score = 0;
            selectedTile = null;
            locked = false;
            createBoard();
            render();
        }

        function showLossMessage() {
            locked = true;
            messageTextEl.textContent = "¬°Juego Terminado! Int√©ntalo de nuevo.";
            nextLevelBtn.style.display = 'none';
            tryAgainBtn.style.display = 'inline-block';
            gameMessageEl.classList.add('show');
        }

        function reset() {
            level = 1;
            targetScore = levelData[1].targetScore;
            moves = levelData[1].moves;
            resetGame();
        }

        nextLevelBtn.addEventListener('click', nextLevel);
        tryAgainBtn.addEventListener('click', reset);
        // resetBtn.addEventListener('click', reset);

        reset();
    </script>
</body>
</html>
